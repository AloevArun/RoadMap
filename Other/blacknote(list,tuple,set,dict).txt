Списки: B = [a, b, c] - (list/изменяемый)

C = B[m, n, step] - срез, записать элементы из B от m до n, с шагом step в новый список C 

.append() - (B.append(A)) добавляет A в конец списка B. При добавлении списка - добавит список как отдельный элемент

.extend() - (B.extend(A)) добавляет элементы списка A в конец списка B

.count() - (B.count(A)) количество вхождений A в списке B. Если нужно узнать, присутствует ли значение в списке или нет, тогда оператор in намного быстрее
if A in B:
	do_some_shit()

.index() - (B.index(A)) возвращает номер элемента A в списке B. По умолчанию, он просматривает весь список, находит только первое вхождение значения в списке. Можно указать вторым аргументом индекс с которого необходимо начать поиск, и третий аргумент — индекс, на котором необходимо остановить поиск. Вернет исключение если не найдет элемент.
B.index(A, 5, 7)

del B[i] - удалить i-тый элемент из B

.remove() - (B.remove(A)) удалить элемент со значением A из B. Удаляет первое вхождение этого значения из списка. Вернет исключение, если попытаться удалить значение которого нет в списке.

.pop() - B.pop(i) без аргументов, удалит последний элемент списка и вернет удаленное значение. При вызове с аргументом i, i-тый элемент будет удалён, а все элементы после него сместятся, чтобы «заполнить пробел». Вернет удалённое из списка значение. Вернет исключение если список пустой.

a = [] - ложь
a = [some_stuff, another_stuff] - истина


Кортежи: B = (a, b, c) - (tuple/неизменяемый)

-Элементы кортежа заданы в определённом порядке, как и в списке.
-Элементы кортежа индексируются с нуля, как и элементы списка, таким образом первый элемент не пустого кортежа — это всегда a_tuple[0]
-Создание среза кортежа аналогично созданию среза списка.
-Когда создаётся срез списка, получается новый список; когда создаётся срез кортежа, получается новый кортеж.
-Основное отличие между кортежами и списками состоит в том, что кортежи не могут быть изменены.
-Кортежи позволяют только взять срез и вести поиск элемента по значению.
-Кортежи быстрее, чем списки.
-Некоторые кортежи могут использоваться в качестве ключей словаря (конкретно, кортежи, содержащие неизменяемые значения, например, строки, числа и другие кортежи). Списки никогда не могут использоваться в качестве ключей словаря, потому что списки - изменяемые объекты.

-Кортежи могут быть преобразованы в списки и наоборот. Встроенная функция tuple() принимает список и возвращает кортеж из всех его элементов, функция list() принимает кортеж и возвращает список. По сути дела, tuple() замораживает список, а list() размораживает кортеж.

a = () - ложь
a = (some_stuff, another_stuff) - истина

в Python можно использовать кортежи, чтобы присваивать значение нескольким переменным сразу:
>>> v = ('a', 2, True)
>>> (x, y, z) = v
>>> x
'a'
>>> y
2
>>> z
True

Можно использовать встроенную функцию range() для быстрого присвоения сразу нескольких последовательных значений:
>>> (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY,
SUNDAY) = range(7)
>>> MONDAY
0
>>> TUESDAY
1
>>> SUNDAY
6


Множества: B = {a, b, c} - (set/изменяемый)

-Содержат неупорядоченные уникальные значения. Одно множество может содержать значения любых типов. Если у вас есть два множества, вы можете совершать над ними любые стандартные операции, например, объединение, пересечение и разность.
-Чтобы создать множество из списка, воспользуйтесь функцией set().
-Можно создать пустое множество:
>>> a_set = set()
>>> a_set
set()
>>> type(a_set)
<class 'set'>
>>> len(a_set)
0
>>> not_sure = {}
>>> type(not_sure)
<class 'dict'>
Напечатанное представление пустого множества выглядит немного странно. '{}' означало бы пустой словарь, а не пустое множество.
-В силу исторических причуд, пришедших из Python 2, нельзя создать пустое множество с помощью двух фигурных скобок. На самом деле, они создают пустой словарь, а не множество.

Есть два способа добавить элементы в существующее множество: .add() и .update().
Если попытаться добавить значение, которое уже присутствует в множестве, ничего не произойдет. Это не приведет в возникновению ошибки; просто нулевое действие.

.add() принимает один аргумент, который может быть любого типа, и добавляет данное значение в множество.

.update() может принимать несколько аргументов(множества, списки), и добавляет все элементы этих объектов к исходному множеству. Так, как если бы вы вызывали .add() и по очереди передавали ему все элементы этих объектов. Повторяющиеся значения игнорируются, поскольку множество не может содержать дубликаты.

.discard() и .remove() принимают в качестве аргумента одиночное значение и удаляют это значение из множества. Различие - .remove() вернет исключение если элемента нет в множестве.

.pop() удаляет один произвольный(да-да СЛУЧАЙНЫЙ!) элемент из множества и возвращает его значение. Вернет исключение, если множество пустое.

.clear() удаляет все элементы множества оставляя множество пустым.

-Чтобы проверить, принадлежит ли значение множеству, используйте оператор in. Он работает так же, как и для списков.

.union() - (объединение) возвращает новое множество, содержащее все элементы каждого из множеств.

.intersection() - (пересечение) возвращает новое множество, содержащее только те элементы, которые есть и в первом множестве, и во втором.

.difference() - A.difference(B) (разность) возвращает новое множество, содержащее все элементы, которые есть в множестве A, но которых нет в B.

.symmetric_difference() - (симметрическая разность) возвращает новое множество, которое содержит только уникальные элементы обоих множеств, т.е. все элементы, кроме тех, которые есть в обоих множествах.

>>> a_set = {1, 2, 3}
>>> b_set = {1, 2, 3, 4}
>>> a_set.issubset(b_set) - Множество a_set является ПОДмножеством b_set — все элементы a_set также являются элементами b_set.
True
>>> b_set.issuperset(a_set) - Множество b_set является НАДмножеством a_set, потому что все элементы a_set также являются элементами b_set
True
65
>>> a_set.add(5)
>>> a_set.issubset(b_set)
False
>>> b_set.issuperset(a_set)
False

В логическом контексте пустое множество — ложь. Любое множество, содержащее хотя бы один элемент — истина. Значения элементов не важны.